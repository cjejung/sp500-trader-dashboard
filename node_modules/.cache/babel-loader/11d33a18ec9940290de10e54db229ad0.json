{"ast":null,"code":"/*!\n* chartjs-plugin-zoom v1.2.0\n* undefined\n * (c) 2016-2021 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, callback, sign } from 'chart.js/helpers';\n\nvar getModifierKey = function getModifierKey(opts) {\n  return opts && opts.enabled && opts.modifierKey;\n};\n\nvar keyPressed = function keyPressed(key, event) {\n  return key && event[key + 'Key'];\n};\n\nvar keyNotPressed = function keyNotPressed(key, event) {\n  return key && !event[key + 'Key'];\n};\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\n\n\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({\n      chart: chart\n    }).indexOf(dir) !== -1;\n  }\n\n  return false;\n}\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\n\n\nfunction debounce(fn, delay) {\n  var timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n/** This function use for check what axis now under mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\n\n\nfunction getScaleUnderPoint(_ref, chart) {\n  var x = _ref.x,\n      y = _ref.y;\n  var scales = chart.scales;\n  var scaleIds = Object.keys(scales);\n\n  for (var i = 0; i < scaleIds.length; i++) {\n    var scale = scales[scaleIds[i]];\n\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n\n  return null;\n}\n/** This function return only one scale whose position is under mouse cursor and which direction is enabled.\n * If under mouse hasn't scale, then return all other scales which 'mode' is diffrent with overScaleMode.\n * So 'overScaleMode' works as a limiter to scale the user-selected scale (in 'mode') only when the cursor is under the scale,\n * and other directions in 'mode' works as before.\n * Example: mode = 'xy', overScaleMode = 'y' -> it's means 'x' - works as before, and 'y' only works for one scale when cursor is under it.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param {string} mode - 'xy', 'x' or 'y'\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\n\n\nfunction getEnabledScalesByPoint(mode, point, chart) {\n  var scale = getScaleUnderPoint(point, chart);\n\n  if (scale && directionEnabled(mode, scale.axis, chart)) {\n    return [scale];\n  }\n\n  var enabledScales = [];\n  each(chart.scales, function (scaleItem) {\n    if (!directionEnabled(mode, scaleItem.axis, chart)) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nvar chartStates = new WeakMap();\n\nfunction getState(chart) {\n  var state = chartStates.get(chart);\n\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(scale, zoom, center) {\n  var range = scale.max - scale.min;\n  var newRange = range * (zoom - 1);\n  var centerPoint = scale.isHorizontal() ? center.x : center.y; // `scale.getValueForPixel()` can return a value less than the `scale.min` or\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\n\n  var minPercent = Math.max(0, Math.min(1, (scale.getValueForPixel(centerPoint) - scale.min) / range || 0));\n  var maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\n\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  var limit = scaleLimits[prop];\n\n  if (limit === 'original') {\n    var original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n\n  return valueOrDefault(limit, fallback);\n}\n\nfunction updateRange(scale, _ref2, limits) {\n  var min = _ref2.min,\n      max = _ref2.max;\n  var zoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var state = getState(scale.chart);\n  var id = scale.id,\n      axis = scale.axis,\n      scaleOpts = scale.options;\n  var scaleLimits = limits && (limits[id] || limits[axis]) || {};\n  var _scaleLimits$minRange = scaleLimits.minRange,\n      minRange = _scaleLimits$minRange === void 0 ? 0 : _scaleLimits$minRange;\n  var minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  var maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  var cmin = Math.max(min, minLimit);\n  var cmax = Math.min(max, maxLimit);\n  var range = zoom ? Math.max(cmax - cmin, minRange) : scale.max - scale.min;\n\n  if (cmax - cmin !== range) {\n    if (minLimit > cmax - range) {\n      min = cmin;\n      max = cmin + range;\n    } else if (maxLimit < cmin + range) {\n      max = cmax;\n      min = cmax - range;\n    } else {\n      var offset = (range - cmax + cmin) / 2;\n      min = cmin - offset;\n      max = cmax + offset;\n    }\n  } else {\n    min = cmin;\n    max = cmax;\n  }\n\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n  state.updatedScaleLimits[scale.id] = {\n    min: min,\n    max: max\n  }; // return true if the scale range is changed\n\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\n\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  var delta = zoomDelta(scale, zoom, center);\n  var newRange = {\n    min: scale.min + delta.min,\n    max: scale.max - delta.max\n  };\n  return updateRange(scale, newRange, limits, true);\n}\n\nvar integerChange = function integerChange(v) {\n  return v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\n};\n\nfunction existCategoryFromMaxZoom(scale) {\n  var labels = scale.getLabels();\n  var maxIndex = labels.length - 1;\n\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\n\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  var delta = zoomDelta(scale, zoom, center);\n\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n\n  var newRange = {\n    min: scale.min + integerChange(delta.min),\n    max: scale.max - integerChange(delta.max)\n  };\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\n\nfunction panCategoryScale(scale, delta, limits) {\n  var labels = scale.getLabels();\n  var lastLabelIndex = labels.length - 1;\n  var min = scale.min,\n      max = scale.max; // The visible range. Ticks can be skipped, and thus not reliable.\n\n  var range = Math.max(max - min, 1); // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n\n  var stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  var stepSize = Math.round(Math.abs(delta / stepDelta));\n  var applied;\n\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n\n  return updateRange(scale, {\n    min: min,\n    max: max\n  }, limits) || applied;\n}\n\nvar OFFSETS = {\n  second: 500,\n  // 500 ms\n  minute: 30 * 1000,\n  // 30 s\n  hour: 30 * 60 * 1000,\n  // 30 m\n  day: 12 * 60 * 60 * 1000,\n  // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000,\n  // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n\n};\n\nfunction panNumericalScale(scale, delta, limits) {\n  var canZoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var prevStart = scale.min,\n      prevEnd = scale.max,\n      options = scale.options;\n  var round = options.time && options.time.round;\n  var offset = OFFSETS[round] || 0;\n  var newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  var newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n\n  var _ref3 = canZoom && limits && limits[scale.axis] || {},\n      _ref3$min = _ref3.min,\n      minLimit = _ref3$min === void 0 ? -Infinity : _ref3$min,\n      _ref3$max = _ref3.max,\n      maxLimit = _ref3$max === void 0 ? Infinity : _ref3$max;\n\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true;\n  }\n\n  return updateRange(scale, {\n    min: newMin,\n    max: newMax\n  }, limits, canZoom);\n}\n\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\n\nvar zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale\n};\nvar panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  var id = scale.id,\n      _scale$options = scale.options,\n      min = _scale$options.min,\n      max = _scale$options.max;\n\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n\n  var previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\n\nfunction removeMissingScales(limits, scales) {\n  each(limits, function (opt, key) {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\n\nfunction storeOriginalScaleLimits(chart, state) {\n  var scales = chart.scales;\n  var originalScaleLimits = state.originalScaleLimits,\n      updatedScaleLimits = state.updatedScaleLimits;\n  each(scales, function (scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {\n          scale: scale.min,\n          options: scale.options.min\n        },\n        max: {\n          scale: scale.max,\n          options: scale.options.max\n        }\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\n\nfunction doZoom(scale, amount, center, limits) {\n  var fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\n\nfunction getCenter(chart) {\n  var ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2\n  };\n}\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\n */\n\n\nfunction zoom(chart, amount) {\n  var transition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'none';\n\n  var _ref4 = typeof amount === 'number' ? {\n    x: amount,\n    y: amount\n  } : amount,\n      _ref4$x = _ref4.x,\n      x = _ref4$x === void 0 ? 1 : _ref4$x,\n      _ref4$y = _ref4.y,\n      y = _ref4$y === void 0 ? 1 : _ref4$y,\n      _ref4$focalPoint = _ref4.focalPoint,\n      focalPoint = _ref4$focalPoint === void 0 ? getCenter(chart) : _ref4$focalPoint;\n\n  var state = getState(chart);\n  var _state$options = state.options,\n      limits = _state$options.limits,\n      zoomOptions = _state$options.zoom;\n\n  var _ref5 = zoomOptions || {},\n      _ref5$mode = _ref5.mode,\n      mode = _ref5$mode === void 0 ? 'xy' : _ref5$mode,\n      overScaleMode = _ref5.overScaleMode;\n\n  storeOriginalScaleLimits(chart, state);\n  var xEnabled = x !== 1 && directionEnabled(mode, 'x', chart);\n  var yEnabled = y !== 1 && directionEnabled(mode, 'y', chart);\n  var enabledScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, focalPoint, chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart: chart\n  }]);\n}\n\nfunction getRange(scale, pixel0, pixel1) {\n  var v0 = scale.getValueForPixel(pixel0);\n  var v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\n\nfunction zoomRect(chart, p0, p1) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  var state = getState(chart);\n  var _state$options2 = state.options,\n      limits = _state$options2.limits,\n      zoomOptions = _state$options2.zoom;\n  var _zoomOptions$mode = zoomOptions.mode,\n      mode = _zoomOptions$mode === void 0 ? 'xy' : _zoomOptions$mode;\n  storeOriginalScaleLimits(chart, state);\n  var xEnabled = directionEnabled(mode, 'x', chart);\n  var yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      updateRange(scale, getRange(scale, p0.x, p1.x), limits, true);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      updateRange(scale, getRange(scale, p0.y, p1.y), limits, true);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart: chart\n  }]);\n}\n\nfunction zoomScale(chart, scaleId, range) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  storeOriginalScaleLimits(chart, getState(chart));\n  var scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\n\nfunction resetZoom(chart) {\n  var transition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n  var state = getState(chart);\n  var originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  each(chart.scales, function (scale) {\n    var scaleOptions = scale.options;\n\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{\n    chart: chart\n  }]);\n}\n\nfunction getOriginalRange(state, scaleId) {\n  var original = state.originalScaleLimits[scaleId];\n\n  if (!original) {\n    return;\n  }\n\n  var min = original.min,\n      max = original.max;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\n\nfunction getZoomLevel(chart) {\n  var state = getState(chart);\n  var min = 1;\n  var max = 1;\n  each(chart.scales, function (scale) {\n    var origRange = getOriginalRange(state, scale.id);\n\n    if (origRange) {\n      var level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\n\nfunction panScale(scale, delta, limits, state) {\n  var panDelta = state.panDelta; // Add possible cumulative delta from previous pan attempts where scale did not change\n\n  var storedDelta = panDelta[scale.id] || 0;\n\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n\n  var fn = panFunctions[scale.type] || panFunctions.default;\n\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\n\nfunction pan(chart, delta, enabledScales) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n\n  var _ref6 = typeof delta === 'number' ? {\n    x: delta,\n    y: delta\n  } : delta,\n      _ref6$x = _ref6.x,\n      x = _ref6$x === void 0 ? 0 : _ref6$x,\n      _ref6$y = _ref6.y,\n      y = _ref6$y === void 0 ? 0 : _ref6$y;\n\n  var state = getState(chart);\n  var _state$options3 = state.options,\n      panOptions = _state$options3.pan,\n      limits = _state$options3.limits;\n\n  var _ref7 = panOptions || {},\n      _ref7$mode = _ref7.mode,\n      mode = _ref7$mode === void 0 ? 'xy' : _ref7$mode,\n      onPan = _ref7.onPan;\n\n  storeOriginalScaleLimits(chart, state);\n  var xEnabled = x !== 0 && directionEnabled(mode, 'x', chart);\n  var yEnabled = y !== 0 && directionEnabled(mode, 'y', chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{\n    chart: chart\n  }]);\n}\n\nfunction getInitialScaleBounds(chart) {\n  var state = getState(chart);\n  var scaleBounds = {};\n\n  for (var _i = 0, _Object$keys = Object.keys(chart.scales); _i < _Object$keys.length; _i++) {\n    var scaleId = _Object$keys[_i];\n\n    var _ref8 = state.originalScaleLimits[scaleId] || {\n      min: {},\n      max: {}\n    },\n        min = _ref8.min,\n        max = _ref8.max;\n\n    scaleBounds[scaleId] = {\n      min: min.scale,\n      max: max.scale\n    };\n  }\n\n  return scaleBounds;\n}\n\nfunction isZoomedOrPanned(chart) {\n  var scaleBounds = getInitialScaleBounds(chart);\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(chart.scales); _i2 < _Object$keys2.length; _i2++) {\n    var scaleId = _Object$keys2[_i2];\n    var _scaleBounds$scaleId = scaleBounds[scaleId],\n        originalMin = _scaleBounds$scaleId.min,\n        originalMax = _scaleBounds$scaleId.max;\n\n    if (chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n\n    if (chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction removeHandler(chart, type) {\n  var _getState = getState(chart),\n      handlers = _getState.handlers;\n\n  var handler = handlers[type];\n\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\n\nfunction addHandler(chart, target, type, handler) {\n  var _getState2 = getState(chart),\n      handlers = _getState2.handlers,\n      options = _getState2.options;\n\n  removeHandler(chart, type);\n\n  handlers[type] = function (event) {\n    return handler(chart, event, options);\n  };\n\n  handlers[type].target = target;\n  target.addEventListener(type, handlers[type]);\n}\n\nfunction mouseMove(chart, event) {\n  var state = getState(chart);\n\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\n\nfunction zoomStart(chart, event, zoomOptions) {\n  var onZoomStart = zoomOptions.onZoomStart,\n      onZoomRejected = zoomOptions.onZoomRejected;\n\n  if (onZoomStart) {\n    var _event$target$getBoun = event.target.getBoundingClientRect(),\n        offsetX = _event$target$getBoun.left,\n        offsetY = _event$target$getBoun.top;\n\n    var point = {\n      x: event.clientX - offsetX,\n      y: event.clientY - offsetY\n    };\n\n    if (callback(onZoomStart, [{\n      chart: chart,\n      event: event,\n      point: point\n    }]) === false) {\n      callback(onZoomRejected, [{\n        chart: chart,\n        event: event\n      }]);\n      return false;\n    }\n  }\n}\n\nfunction mouseDown(chart, event) {\n  var state = getState(chart);\n  var _state$options4 = state.options,\n      panOptions = _state$options4.pan,\n      _state$options4$zoom = _state$options4.zoom,\n      zoomOptions = _state$options4$zoom === void 0 ? {} : _state$options4$zoom;\n\n  if (keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {\n    return callback(zoomOptions.onZoomRejected, [{\n      chart: chart,\n      event: event\n    }]);\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  state.dragStart = event;\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n}\n\nfunction computeDragRect(chart, mode, beginPoint, endPoint) {\n  var _beginPoint$target$ge = beginPoint.target.getBoundingClientRect(),\n      offsetX = _beginPoint$target$ge.left,\n      offsetY = _beginPoint$target$ge.top;\n\n  var xEnabled = directionEnabled(mode, 'x', chart);\n  var yEnabled = directionEnabled(mode, 'y', chart);\n  var _chart$chartArea = chart.chartArea,\n      top = _chart$chartArea.top,\n      left = _chart$chartArea.left,\n      right = _chart$chartArea.right,\n      bottom = _chart$chartArea.bottom,\n      chartWidth = _chart$chartArea.width,\n      chartHeight = _chart$chartArea.height;\n\n  if (xEnabled) {\n    left = Math.min(beginPoint.clientX, endPoint.clientX) - offsetX;\n    right = Math.max(beginPoint.clientX, endPoint.clientX) - offsetX;\n  }\n\n  if (yEnabled) {\n    top = Math.min(beginPoint.clientY, endPoint.clientY) - offsetY;\n    bottom = Math.max(beginPoint.clientY, endPoint.clientY) - offsetY;\n  }\n\n  var width = right - left;\n  var height = bottom - top;\n  return {\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom,\n    width: width,\n    height: height,\n    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,\n    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1\n  };\n}\n\nfunction mouseUp(chart, event) {\n  var state = getState(chart);\n\n  if (!state.dragStart) {\n    return;\n  }\n\n  removeHandler(chart, 'mousemove');\n  var _state$options$zoom = state.options.zoom,\n      mode = _state$options$zoom.mode,\n      onZoomComplete = _state$options$zoom.onZoomComplete,\n      _state$options$zoom$d = _state$options$zoom.drag.threshold,\n      threshold = _state$options$zoom$d === void 0 ? 0 : _state$options$zoom$d;\n  var rect = computeDragRect(chart, mode, state.dragStart, event);\n  var distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  var distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  var distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY); // Remove drag start and end before chart update to stop drawing selected area\n\n  state.dragStart = state.dragEnd = null;\n\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n\n  zoomRect(chart, {\n    x: rect.left,\n    y: rect.top\n  }, {\n    x: rect.right,\n    y: rect.bottom\n  }, 'zoom');\n  setTimeout(function () {\n    return state.dragging = false;\n  }, 500);\n  callback(onZoomComplete, [{\n    chart: chart\n  }]);\n}\n\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{\n      chart: chart,\n      event: event\n    }]);\n    return;\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  } // Prevent the event from triggering the default behavior (eg. Content scrolling).\n\n\n  if (event.cancelable) {\n    event.preventDefault();\n  } // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n\n\n  if (event.deltaY === undefined) {\n    return;\n  }\n\n  return true;\n}\n\nfunction wheel(chart, event) {\n  var _getState3 = getState(chart),\n      onZoomComplete = _getState3.handlers.onZoomComplete,\n      zoomOptions = _getState3.options.zoom;\n\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n\n  var rect = event.target.getBoundingClientRect();\n  var speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  var amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount);\n\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\n\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(function () {\n      return callback(handler, [{\n        chart: chart\n      }]);\n    }, delay);\n  }\n}\n\nfunction addListeners(chart, options) {\n  var canvas = chart.canvas;\n  var _options$zoom = options.zoom,\n      wheelOptions = _options$zoom.wheel,\n      dragOptions = _options$zoom.drag,\n      onZoomComplete = _options$zoom.onZoomComplete; // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n  }\n}\n\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n}\n\nfunction createEnabler(chart, state) {\n  return function (recognizer, event) {\n    var _state$options5 = state.options,\n        panOptions = _state$options5.pan,\n        _state$options5$zoom = _state$options5.zoom,\n        zoomOptions = _state$options5$zoom === void 0 ? {} : _state$options5$zoom;\n\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n\n    var srcEvent = event && event.srcEvent;\n\n    if (!srcEvent) {\n      // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n\n    if (!state.panning && event.pointerType === 'mouse' && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {\n      callback(panOptions.onPanRejected, [{\n        chart: chart,\n        event: event\n      }]);\n      return false;\n    }\n\n    return true;\n  };\n}\n\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  var pinchX = Math.abs(p0.clientX - p1.clientX);\n  var pinchY = Math.abs(p0.clientY - p1.clientY); // diagonal fingers will change both (xy) axes\n\n  var p = pinchX / pinchY;\n  var x, y;\n\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    var center = e.center,\n        pointers = e.pointers; // Hammer reports the total scaling. We need the incremental amount\n\n    var zoomPercent = 1 / state.scale * e.scale;\n    var rect = e.target.getBoundingClientRect();\n    var pinch = pinchAxes(pointers[0], pointers[1]);\n    var mode = state.options.zoom.mode;\n    var amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount); // Keep track of overall scale\n\n    state.scale = e.scale;\n  }\n}\n\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\n\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n\n    callback(state.options.zoom.onZoomComplete, [{\n      chart: chart\n    }]);\n  }\n}\n\nfunction handlePan(chart, state, e) {\n  var delta = state.delta;\n\n  if (delta) {\n    state.panning = true;\n    pan(chart, {\n      x: e.deltaX - delta.x,\n      y: e.deltaY - delta.y\n    }, state.panScales);\n    state.delta = {\n      x: e.deltaX,\n      y: e.deltaY\n    };\n  }\n}\n\nfunction startPan(chart, state, event) {\n  var _state$options$pan = state.options.pan,\n      enabled = _state$options$pan.enabled,\n      overScaleMode = _state$options$pan.overScaleMode,\n      onPanStart = _state$options$pan.onPanStart,\n      onPanRejected = _state$options$pan.onPanRejected;\n\n  if (!enabled) {\n    return;\n  }\n\n  var rect = event.target.getBoundingClientRect();\n  var point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n\n  if (callback(onPanStart, [{\n    chart: chart,\n    event: event,\n    point: point\n  }]) === false) {\n    return callback(onPanRejected, [{\n      chart: chart,\n      event: event\n    }]);\n  }\n\n  state.panScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, point, chart);\n  state.delta = {\n    x: 0,\n    y: 0\n  };\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\n\nfunction endPan(chart, state) {\n  state.delta = null;\n\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(function () {\n      return state.panning = false;\n    }, 500);\n    callback(state.options.pan.onPanComplete, [{\n      chart: chart\n    }]);\n  }\n}\n\nvar hammers = new WeakMap();\n\nfunction startHammer(chart, options) {\n  var state = getState(chart);\n  var canvas = chart.canvas;\n  var panOptions = options.pan,\n      zoomOptions = options.zoom;\n  var mc = new Hammer.Manager(canvas);\n\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', function () {\n      return startPinch(chart, state);\n    });\n    mc.on('pinch', function (e) {\n      return handlePinch(chart, state, e);\n    });\n    mc.on('pinchend', function (e) {\n      return endPinch(chart, state, e);\n    });\n  }\n\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', function (e) {\n      return startPan(chart, state, e);\n    });\n    mc.on('panmove', function (e) {\n      return handlePan(chart, state, e);\n    });\n    mc.on('panend', function () {\n      return endPan(chart, state);\n    });\n  }\n\n  hammers.set(chart, mc);\n}\n\nfunction stopHammer(chart) {\n  var mc = hammers.get(chart);\n\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\n\nvar version = \"1.2.0\";\nvar plugin = {\n  id: 'zoom',\n  version: version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy'\n    }\n  },\n  start: function start(chart, _args, options) {\n    var state = getState(chart);\n    state.options = options;\n\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n\n    chart.pan = function (delta, panScales, transition) {\n      return pan(chart, delta, panScales, transition);\n    };\n\n    chart.zoom = function (args, transition) {\n      return zoom(chart, args, transition);\n    };\n\n    chart.zoomScale = function (id, range, transition) {\n      return zoomScale(chart, id, range, transition);\n    };\n\n    chart.resetZoom = function (transition) {\n      return resetZoom(chart, transition);\n    };\n\n    chart.getZoomLevel = function () {\n      return getZoomLevel(chart);\n    };\n\n    chart.getInitialScaleBounds = function () {\n      return getInitialScaleBounds(chart);\n    };\n\n    chart.isZoomedOrPanned = function () {\n      return isZoomedOrPanned(chart);\n    };\n  },\n  beforeEvent: function beforeEvent(chart) {\n    var state = getState(chart);\n\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n  beforeUpdate: function beforeUpdate(chart, args, options) {\n    var state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw: function beforeDatasetsDraw(chart, args, options) {\n    var _getState4 = getState(chart),\n        dragStart = _getState4.dragStart,\n        dragEnd = _getState4.dragEnd;\n\n    if (dragEnd) {\n      var _computeDragRect = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd),\n          left = _computeDragRect.left,\n          top = _computeDragRect.top,\n          width = _computeDragRect.width,\n          height = _computeDragRect.height;\n\n      var dragOptions = options.zoom.drag;\n      var ctx = chart.ctx;\n      ctx.save();\n      ctx.beginPath();\n      ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n      ctx.fillRect(left, top, width, height);\n\n      if (dragOptions.borderWidth > 0) {\n        ctx.lineWidth = dragOptions.borderWidth;\n        ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n        ctx.strokeRect(left, top, width, height);\n      }\n\n      ctx.restore();\n    }\n  },\n  stop: function stop(chart) {\n    removeListeners(chart);\n\n    if (Hammer) {\n      stopHammer(chart);\n    }\n\n    removeState(chart);\n  },\n  panFunctions: panFunctions,\n  zoomFunctions: zoomFunctions\n};\nexport { plugin as default, pan, resetZoom, zoom, zoomScale };","map":{"version":3,"sources":["/home/lu/sp500-trader-dashboard/node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js"],"names":["Hammer","each","valueOrDefault","callback","sign","getModifierKey","opts","enabled","modifierKey","keyPressed","key","event","keyNotPressed","directionEnabled","mode","dir","chart","undefined","indexOf","debounce","fn","delay","timeout","clearTimeout","setTimeout","getScaleUnderPoint","x","y","scales","scaleIds","Object","keys","i","length","scale","top","bottom","left","right","getEnabledScalesByPoint","point","axis","enabledScales","scaleItem","push","chartStates","WeakMap","getState","state","get","originalScaleLimits","updatedScaleLimits","handlers","panDelta","set","removeState","delete","zoomDelta","zoom","center","range","max","min","newRange","centerPoint","isHorizontal","minPercent","Math","getValueForPixel","maxPercent","getLimit","scaleLimits","prop","fallback","limit","original","id","options","updateRange","limits","scaleOpts","minRange","minLimit","Infinity","maxLimit","cmin","cmax","offset","parse","zoomNumericalScale","delta","integerChange","v","isNaN","round","existCategoryFromMaxZoom","labels","getLabels","maxIndex","zoomCategoryScale","scaleLength","width","height","panCategoryScale","lastLabelIndex","stepDelta","stepSize","abs","applied","OFFSETS","second","minute","hour","day","week","month","quarter","year","panNumericalScale","canZoom","prevStart","prevEnd","time","newMin","getPixelForValue","newMax","panNonLinearScale","zoomFunctions","category","default","panFunctions","logarithmic","timeseries","shouldUpdateScaleLimits","previous","removeMissingScales","opt","storeOriginalScaleLimits","doZoom","amount","type","getCenter","ca","chartArea","transition","focalPoint","zoomOptions","overScaleMode","xEnabled","yEnabled","update","onZoom","getRange","pixel0","pixel1","v0","v1","zoomRect","p0","p1","zoomScale","scaleId","resetZoom","scaleOptions","onZoomComplete","getOriginalRange","getZoomLevel","origRange","level","panScale","storedDelta","pan","panOptions","onPan","getInitialScaleBounds","scaleBounds","isZoomedOrPanned","originalMin","originalMax","removeHandler","handler","target","removeEventListener","addHandler","addEventListener","mouseMove","dragStart","dragging","dragEnd","zoomStart","onZoomStart","onZoomRejected","getBoundingClientRect","offsetX","offsetY","clientX","clientY","mouseDown","drag","canvas","computeDragRect","beginPoint","endPoint","chartWidth","chartHeight","zoomX","zoomY","mouseUp","threshold","rect","distanceX","distanceY","distance","sqrt","wheelPreconditions","wheel","cancelable","preventDefault","deltaY","speed","addDebouncedHandler","name","addListeners","wheelOptions","dragOptions","ownerDocument","removeListeners","createEnabler","recognizer","srcEvent","panning","pointerType","onPanRejected","pinchAxes","pinchX","pinchY","p","handlePinch","e","pointers","zoomPercent","pinch","startPinch","endPinch","handlePan","deltaX","panScales","startPan","onPanStart","panEndTimeout","endPan","onPanComplete","hammers","startHammer","mc","Manager","add","Pinch","on","Pan","enable","stopHammer","remove","destroy","version","plugin","defaults","start","_args","prototype","hasOwnProperty","call","console","warn","args","beforeEvent","beforeUpdate","beforeDatasetsDraw","ctx","save","beginPath","fillStyle","backgroundColor","fillRect","borderWidth","lineWidth","strokeStyle","borderColor","strokeRect","restore","stop"],"mappings":"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","sourcesContent":["/*!\n* chartjs-plugin-zoom v1.2.0\n* undefined\n * (c) 2016-2021 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, callback, sign } from 'chart.js/helpers';\n\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\n\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({chart}).indexOf(dir) !== -1;\n  }\n\n  return false;\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\nfunction debounce(fn, delay) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n\n/** This function use for check what axis now under mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\nfunction getScaleUnderPoint({x, y}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\n\n/** This function return only one scale whose position is under mouse cursor and which direction is enabled.\n * If under mouse hasn't scale, then return all other scales which 'mode' is diffrent with overScaleMode.\n * So 'overScaleMode' works as a limiter to scale the user-selected scale (in 'mode') only when the cursor is under the scale,\n * and other directions in 'mode' works as before.\n * Example: mode = 'xy', overScaleMode = 'y' -> it's means 'x' - works as before, and 'y' only works for one scale when cursor is under it.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param {string} mode - 'xy', 'x' or 'y'\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\nfunction getEnabledScalesByPoint(mode, point, chart) {\n  const scale = getScaleUnderPoint(point, chart);\n\n  if (scale && directionEnabled(mode, scale.axis, chart)) {\n    return [scale];\n  }\n\n  const enabledScales = [];\n  each(chart.scales, function(scaleItem) {\n    if (!directionEnabled(mode, scaleItem.axis, chart)) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nconst chartStates = new WeakMap();\n\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n\n  const centerPoint = scale.isHorizontal() ? center.x : center.y;\n  // `scale.getValueForPixel()` can return a value less than the `scale.min` or\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\n  const minPercent = Math.max(0, Math.min(1,\n    (scale.getValueForPixel(centerPoint) - scale.min) / range || 0\n  ));\n\n  const maxPercent = 1 - minPercent;\n\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\n\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\n\nfunction updateRange(scale, {min, max}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {id, axis, options: scaleOpts} = scale;\n\n  const scaleLimits = limits && (limits[id] || limits[axis]) || {};\n  const {minRange = 0} = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n\n  const cmin = Math.max(min, minLimit);\n  const cmax = Math.min(max, maxLimit);\n  const range = zoom ? Math.max(cmax - cmin, minRange) : scale.max - scale.min;\n  if (cmax - cmin !== range) {\n    if (minLimit > cmax - range) {\n      min = cmin;\n      max = cmin + range;\n    } else if (maxLimit < cmin + range) {\n      max = cmax;\n      min = cmax - range;\n    } else {\n      const offset = (range - cmax + cmin) / 2;\n      min = cmin - offset;\n      max = cmax + offset;\n    }\n  } else {\n    min = cmin;\n    max = cmax;\n  }\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n\n  state.updatedScaleLimits[scale.id] = {min, max};\n\n  // return true if the scale range is changed\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\n\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};\n  return updateRange(scale, newRange, limits, true);\n}\n\nconst integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\n\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\n\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\n\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {min, max} = scale;\n  // The visible range. Ticks can be skipped, and thus not reliable.\n  const range = Math.max(max - min, 1);\n  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n\n  return updateRange(scale, {min, max}, limits) || applied;\n}\n\nconst OFFSETS = {\n  second: 500, // 500 ms\n  minute: 30 * 1000, // 30 s\n  hour: 30 * 60 * 1000, // 30 m\n  day: 12 * 60 * 60 * 1000, // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000, // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000, // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000, // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n};\n\nfunction panNumericalScale(scale, delta, limits, canZoom = false) {\n  const {min: prevStart, max: prevEnd, options} = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  const {min: minLimit = -Infinity, max: maxLimit = Infinity} = canZoom && limits && limits[scale.axis] || {};\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true;\n  }\n  return updateRange(scale, {min: newMin, max: newMax}, limits, canZoom);\n}\n\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\n\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n};\n\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale,\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {id, options: {min, max}} = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\n\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\n\nfunction storeOriginalScaleLimits(chart, state) {\n  const {scales} = chart;\n  const {originalScaleLimits, updatedScaleLimits} = state;\n\n  each(scales, function(scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {scale: scale.min, options: scale.options.min},\n        max: {scale: scale.max, options: scale.options.max},\n      };\n    }\n  });\n\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\n\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\n\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2,\n  };\n}\n\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\n */\nfunction zoom(chart, amount, transition = 'none') {\n  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  const {mode = 'xy', overScaleMode} = zoomOptions || {};\n\n  storeOriginalScaleLimits(chart, state);\n\n  const xEnabled = x !== 1 && directionEnabled(mode, 'x', chart);\n  const yEnabled = y !== 1 && directionEnabled(mode, 'y', chart);\n  const enabledScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, focalPoint, chart);\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction getRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\n\nfunction zoomRect(chart, p0, p1, transition = 'none') {\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  const {mode = 'xy'} = zoomOptions;\n\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n\n  each(chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      updateRange(scale, getRange(scale, p0.x, p1.x), limits, true);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      updateRange(scale, getRange(scale, p0.y, p1.y), limits, true);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction zoomScale(chart, scaleId, range, transition = 'none') {\n  storeOriginalScaleLimits(chart, getState(chart));\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\n\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n\n  each(chart.scales, function(scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{chart}]);\n}\n\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {min, max} = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\n\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function(scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\n\nfunction panScale(scale, delta, limits, state) {\n  const {panDelta} = state;\n  // Add possible cumulative delta from previous pan attempts where scale did not change\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\n\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;\n  const state = getState(chart);\n  const {options: {pan: panOptions, limits}} = state;\n  const {mode = 'xy', onPan} = panOptions || {};\n\n  storeOriginalScaleLimits(chart, state);\n\n  const xEnabled = x !== 0 && directionEnabled(mode, 'x', chart);\n  const yEnabled = y !== 0 && directionEnabled(mode, 'y', chart);\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(onPan, [{chart}]);\n}\n\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min, max} = state.originalScaleLimits[scaleId] || {min: {}, max: {}};\n    scaleBounds[scaleId] = {min: min.scale, max: max.scale};\n  }\n\n  return scaleBounds;\n}\n\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min: originalMin, max: originalMax} = scaleBounds[scaleId];\n\n    if (chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n\n    if (chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction removeHandler(chart, type) {\n  const {handlers} = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\n\nfunction addHandler(chart, target, type, handler) {\n  const {handlers, options} = getState(chart);\n  removeHandler(chart, type);\n  handlers[type] = (event) => handler(chart, event, options);\n  handlers[type].target = target;\n  target.addEventListener(type, handlers[type]);\n}\n\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\n\nfunction zoomStart(chart, event, zoomOptions) {\n  const {onZoomStart, onZoomRejected} = zoomOptions;\n  if (onZoomStart) {\n    const {left: offsetX, top: offsetY} = event.target.getBoundingClientRect();\n    const point = {\n      x: event.clientX - offsetX,\n      y: event.clientY - offsetY\n    };\n    if (callback(onZoomStart, [{chart, event, point}]) === false) {\n      callback(onZoomRejected, [{chart, event}]);\n      return false;\n    }\n  }\n}\n\nfunction mouseDown(chart, event) {\n  const state = getState(chart);\n  const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n  if (keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {\n    return callback(zoomOptions.onZoomRejected, [{chart, event}]);\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n}\n\nfunction computeDragRect(chart, mode, beginPoint, endPoint) {\n  const {left: offsetX, top: offsetY} = beginPoint.target.getBoundingClientRect();\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  let {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;\n\n  if (xEnabled) {\n    left = Math.min(beginPoint.clientX, endPoint.clientX) - offsetX;\n    right = Math.max(beginPoint.clientX, endPoint.clientX) - offsetX;\n  }\n\n  if (yEnabled) {\n    top = Math.min(beginPoint.clientY, endPoint.clientY) - offsetY;\n    bottom = Math.max(beginPoint.clientY, endPoint.clientY) - offsetY;\n  }\n  const width = right - left;\n  const height = bottom - top;\n\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,\n    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1\n  };\n}\n\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n\n  removeHandler(chart, 'mousemove');\n  const {mode, onZoomComplete, drag: {threshold = 0}} = state.options.zoom;\n  const rect = computeDragRect(chart, mode, state.dragStart, event);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n  // Remove drag start and end before chart update to stop drawing selected area\n  state.dragStart = state.dragEnd = null;\n\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n\n  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom');\n\n  setTimeout(() => (state.dragging = false), 500);\n  callback(onZoomComplete, [{chart}]);\n}\n\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{chart, event}]);\n    return;\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  // Prevent the event from triggering the default behavior (eg. Content scrolling).\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n\n  // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\n\nfunction wheel(chart, event) {\n  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);\n\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n\n  const rect = event.target.getBoundingClientRect();\n  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  const amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n\n  zoom(chart, amount);\n\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\n\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{chart}]), delay);\n  }\n}\n\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;\n\n  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n  }\n}\n\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n}\n\nfunction createEnabler(chart, state) {\n  return function(recognizer, event) {\n    const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) { // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (\n      keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))\n    ) {\n      callback(panOptions.onPanRejected, [{chart, event}]);\n      return false;\n    }\n    return true;\n  };\n}\n\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n\n  // diagonal fingers will change both (xy) axes\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {x, y};\n}\n\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {center, pointers} = e;\n    // Hammer reports the total scaling. We need the incremental amount\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n\n    zoom(chart, amount);\n\n    // Keep track of overall scale\n    state.scale = e.scale;\n  }\n}\n\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\n\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n    callback(state.options.zoom.onZoomComplete, [{chart}]);\n  }\n}\n\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);\n    state.delta = {x: e.deltaX, y: e.deltaY};\n  }\n}\n\nfunction startPan(chart, state, event) {\n  const {enabled, overScaleMode, onPanStart, onPanRejected} = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n\n  if (callback(onPanStart, [{chart, event, point}]) === false) {\n    return callback(onPanRejected, [{chart, event}]);\n  }\n\n  state.panScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, point, chart);\n  state.delta = {x: 0, y: 0};\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\n\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(() => (state.panning = false), 500);\n    callback(state.options.pan.onPanComplete, [{chart}]);\n  }\n}\n\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {pan: panOptions, zoom: zoomOptions} = options;\n\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', () => startPinch(chart, state));\n    mc.on('pinch', (e) => handlePinch(chart, state, e));\n    mc.on('pinchend', (e) => endPinch(chart, state, e));\n  }\n\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', (e) => startPan(chart, state, e));\n    mc.on('panmove', (e) => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n\n  hammers.set(chart, mc);\n}\n\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\n\nvar version = \"1.2.0\";\n\nvar plugin = {\n  id: 'zoom',\n\n  version,\n\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null,\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy',\n    }\n  },\n\n  start: function(chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = (transition) => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n  },\n\n  beforeEvent(chart) {\n    const state = getState(chart);\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n\n  beforeUpdate: function(chart, args, options) {\n    const state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n\n  beforeDatasetsDraw: function(chart, args, options) {\n    const {dragStart, dragEnd} = getState(chart);\n\n    if (dragEnd) {\n      const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);\n\n      const dragOptions = options.zoom.drag;\n      const ctx = chart.ctx;\n\n      ctx.save();\n      ctx.beginPath();\n      ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n      ctx.fillRect(left, top, width, height);\n\n      if (dragOptions.borderWidth > 0) {\n        ctx.lineWidth = dragOptions.borderWidth;\n        ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n        ctx.strokeRect(left, top, width, height);\n      }\n      ctx.restore();\n    }\n  },\n\n  stop: function(chart) {\n    removeListeners(chart);\n\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n\n  panFunctions,\n\n  zoomFunctions\n};\n\nexport { plugin as default, pan, resetZoom, zoom, zoomScale };\n"]},"metadata":{},"sourceType":"module"}